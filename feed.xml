<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Premsai blogs</title>
    <description>Technical explorations in web development, backend systems, AI/ML, and developer tooling — built by a developer, for developers.</description>
    <link>http://sajjapremsai.github.io/blogs/</link>
    <atom:link href="http://sajjapremsai.github.io/blogs/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sat, 28 Jun 2025 05:00:10 +0000</pubDate>
    <lastBuildDate>Sat, 28 Jun 2025 05:00:10 +0000</lastBuildDate>
    <generator>Jekyll v4.3.4</generator>
    
      <item>
        <title>Advanced CSRF: How to Bypass SameSite Cookie Protections</title>
        <description>&lt;p&gt;Samesite is the browser security mechanism that determine when a website’s cookies are  included in the requesting originating from another websites. Since 2021 the chrome makes the lax as the default for samesite restrictions.&lt;/p&gt;

&lt;h4 id=&quot;what-is-the-site-in-context-of-samesite&quot;&gt;What is the site in context of samesite&lt;/h4&gt;

&lt;p&gt;A site is defined as the top level domain (TLD), usually something like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.net&lt;/code&gt; or .&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;com&lt;/code&gt;. When determining whether a request is same-site or not, the URL schema also takes into consideration. This means that a link from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;http://mydomain.com&lt;/code&gt; to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;https://mydomain.com&lt;/code&gt; considered or treated as the cross-site by most of the browsers.&lt;/p&gt;

&lt;div style=&quot;max-width: 100%; overflow-x: auto;&quot;&gt;
  &lt;img src=&quot;/blogs/assets/websecurity/site.png&quot; alt=&quot;site&quot; style=&quot;width: 100%; height: auto;&quot; /&gt;
&lt;/div&gt;

&lt;h4 id=&quot;site-vs-origin&quot;&gt;Site vs Origin&lt;/h4&gt;

&lt;p&gt;The difference between the site and the origin is their scope. The site describes multiple domains whereas the origin only describes one. It not use these words interchangeably which makes serious security implications.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;So when we talk about the like site it is the combination of scheme, TLD and TLD+1. so it will have multiple subdomains.&lt;/li&gt;
  &lt;li&gt;Whereas the origin the combination of ip and port which makes unique and single one.&lt;/li&gt;
&lt;/ul&gt;

&lt;div style=&quot;max-width: 100%; overflow-x: auto;&quot;&gt;
  &lt;img src=&quot;/blogs/assets/websecurity/sitevsorigin.png&quot; alt=&quot;Origin vs Site&quot; style=&quot;width: 100%; height: auto;&quot; /&gt;
&lt;/div&gt;

&lt;h2 id=&quot;understanding-the-working-of-samesite&quot;&gt;Understanding the working of SameSite&lt;/h2&gt;

</description>
        <pubDate>Fri, 27 Jun 2025 19:00:00 +0000</pubDate>
        <link>http://sajjapremsai.github.io/blogs/2025/06/27/adva-csrf/</link>
        <guid isPermaLink="true">http://sajjapremsai.github.io/blogs/2025/06/27/adva-csrf/</guid>
        
        
      </item>
    
      <item>
        <title>CSRF (Cross-Site Request Forgery)</title>
        <description>&lt;h1 id=&quot;understanding-csrf-attacks-cross-site-request-forgery&quot;&gt;Understanding CSRF Attacks: Cross-Site Request Forgery&lt;/h1&gt;

&lt;h2 id=&quot;what-is-a-csrf-attack&quot;&gt;What is a CSRF Attack?&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;CSRF (Cross-Site Request Forgery)&lt;/strong&gt; is a type of web security vulnerability that allows an attacker to trick a logged-in user into unknowingly submitting malicious requests to a web application where they are authenticated.&lt;/p&gt;

&lt;p&gt;When a user logs into a website, they often receive authentication tokens (such as JWT tokens), which are stored in the browser (typically as cookies). These tokens enable persistent sessions without requiring the user to log in repeatedly.&lt;/p&gt;

&lt;p&gt;However, if the user clicks on a &lt;strong&gt;malicious link&lt;/strong&gt; or visits a malicious website, the attacker can craft a hidden form or script that sends an unauthorized request to the original website. Since the user’s browser includes the stored authentication token, the server treats the request as legitimate.&lt;/p&gt;

&lt;p&gt;The scary part? The user has &lt;strong&gt;no idea&lt;/strong&gt; this action took place.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;example-of-a-csrf-attack&quot;&gt;Example of a CSRF Attack&lt;/h2&gt;

&lt;p&gt;Let’s say there’s a trusted and widely-used website:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;https://popularwebsite.com
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;To keep users logged in, the site stores JWT tokens in the browser cookies.&lt;/p&gt;

&lt;p&gt;Now suppose there’s a sensitive endpoint on this site:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;POST https://popularwebsite.com/user/update-email
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;An attacker creates a malicious webpage like the one below:&lt;/p&gt;

&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;html&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;body&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;onload=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;document.forms[0].submit()&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;h1&amp;gt;&lt;/span&gt;You&apos;ve won a prize!&lt;span class=&quot;nt&quot;&gt;&amp;lt;/h1&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;form&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;action=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;https://popularwebsite.com/user/update-email&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;method=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;POST&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;input&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;hidden&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;email&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;hacker@example.com&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/form&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;If the user is &lt;strong&gt;logged in&lt;/strong&gt; to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;popularwebsite.com&lt;/code&gt; and visits this page, their browser will automatically include the JWT token stored in the cookie. As a result, the server will accept the request and update the user’s email address without their knowledge.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;what-makes-the-csrf-possible&quot;&gt;What makes the CSRF possible&lt;/h2&gt;

&lt;p&gt;For a CSRF attack to be successful, three conditions must be met by the attacker&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;There is a sensitive action within the application that the attacker wants to trigger. This action might be a privileged action or any action on user specific data.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The user must be logged into the target website for the malicious request to succeed. Then only whatever action is induced by the attacker will successful.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The required parameters for the request must be known. If a parameter such as a CSRF token is unknown or unpredictable, the attack is likely to fail.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;defenses-against-csrf&quot;&gt;Defenses against CSRF&lt;/h2&gt;

&lt;h4 id=&quot;csrf-token&quot;&gt;CSRF Token&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CSRF Token&lt;/code&gt; is a token generated at the server side and sent to the user while accessing the form. Whenever the form is submitted or any request is sent using methods like POST, PUT, DELETE, etc., the CSRF token is sent along with the request parameters.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;You might wonder where this token is stored. Typically, when we access the website, the server generates a CSRF token and sends it to the client. This token is often stored in a hidden form field or sometimes in a cookie.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;form&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;change-email-form&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;action=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/my-account/change-email&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;method=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;POST&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;&amp;lt;label&amp;gt;&lt;/span&gt;Email&lt;span class=&quot;nt&quot;&gt;&amp;lt;/label&amp;gt;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;&amp;lt;input&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;required&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;email&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;email&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;example@normal-website.com&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;&amp;lt;input&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;required&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;hidden&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;csrf&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;50FaWgdOhi9M9wyna8taR1k3ODOR8d6u&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;&amp;lt;button&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;button&apos;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;submit&apos;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt; Update email &lt;span class=&quot;nt&quot;&gt;&amp;lt;/button&amp;gt;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;&amp;lt;/form&amp;gt;&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;If it’s in the HTML form, the attacker &lt;strong&gt;cannot access&lt;/strong&gt; that token due to &lt;strong&gt;Same-Origin Policy&lt;/strong&gt; — which blocks JavaScript from another domain from reading your page’s DOM.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;But sometimes the CSRF token is stored in cookies. Here, there’s a &lt;strong&gt;chance for vulnerability&lt;/strong&gt;. Because cookies are stored in the browser, and if proper restrictions are not applied, they might be accessed by other websites if the browser sends them automatically.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;To protect the token in the cookie, we can mark it as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HttpOnly&lt;/code&gt;. This makes the cookie &lt;strong&gt;not accessible to JavaScript&lt;/strong&gt;, preventing attackers from reading it even if XSS is possible.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;But still, there is another issue. Cookies are &lt;strong&gt;automatically added to every request&lt;/strong&gt; going to the origin, even if the request is triggered from a different origin. So if the attacker creates a fake form or script pointing to the target website, the browser might &lt;strong&gt;still include&lt;/strong&gt; the cookies (including the CSRF token or session ID).&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;To prevent this, we also set the cookie property &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SameSite=Strict&lt;/code&gt;. This tells the browser to only include cookies in requests that come from &lt;strong&gt;the same origin&lt;/strong&gt;. So even if the attacker builds a custom website and tries to trigger a request, the browser &lt;strong&gt;won’t send the cookies&lt;/strong&gt;, making the CSRF fail.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;situations-that-fails-csrf-validation&quot;&gt;Situations that fails CSRF Validation&lt;/h2&gt;

&lt;p&gt;Now we will see the situations that lets attackers do the action even with the CSRF token. And these situation was created by the developer without knowing which leads to make the site vulnerable and allows the CSRF attacks. Lets go through each one.&lt;/p&gt;

&lt;h4 id=&quot;inappropriately-using-the-get-method-to-data-updation-or-creation&quot;&gt;Inappropriately using the GET method to data updation or creation.&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;CSRF token validation usually depends on the HTTP method. Tokens are &lt;strong&gt;not typically validated&lt;/strong&gt; for GET requests because these are expected to be safe and idempotent. Yeah why we need because we create the CSRF token and send in the GET request usually if the request page contains form.&lt;/li&gt;
  &lt;li&gt;If the developers uses the appropriate methods to handle request which leads to a vulnerability here. For example, if a website allows users to update their email address using a GET request instead of PATCH or POST, it introduces a vulnerability because CSRF tokens are not generally validated on GET requests. Now we know that CSRF token are usually not validated at the GET method. Which leads to can bypass the method and exploit the attack.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;validating-the-csrf-token-based-on-its-presence&quot;&gt;Validating the CSRF token based on its presence&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;In some applications the CSRF token will be validated based on its presence. This allows attackers to send requests without a valid CSRF token, and the server may still process them because it only checks whether the token is present, not whether it’s correct or tied to the session.&lt;/li&gt;
  &lt;li&gt;By sending the request without CSRF token by following makes attack success&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;POST /email/change HTTP/1.1 
Host: iranwebsite.com 
Content-Type: application/x-www-form-urlencoded 
Content-Length: 25 
Cookie: session=2yQIDcpia41WrATfjPqvm9tOkDvkMvLm 

email=trumpwithb2bommer.com
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;Since the application &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;iranwebsite.com&lt;/code&gt; cannot validate the CSRF token if the token is doesn’t present in the request. The request will fulfilled and let the attacker allows his request.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;global-token-pool-issue&quot;&gt;Global token pool issue&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;This is another issue where CSRF tokens are stored in a global pool instead of being tied to individual user sessions.For example, if all users’ CSRF tokens are stored in a single shared store and the application only checks for token existence, any user’s token might be accepted, leading to vulnerabilities.&lt;/li&gt;
  &lt;li&gt;If attacker creates a account and using his csrf token he can access the site since the token is stores in the global pool not user separate session.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;when-csrf-token-is--tie-to-the-non-session-cookie&quot;&gt;When CSRF token is  tie to the non-Session cookie&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;This is a situation where CSRF token is not tied to session means lets take a example that user A has logged in he gets a session id and csrf token. If server only checks the csrf token and allow the request which allows the attack&lt;/li&gt;
  &lt;li&gt;See If a User A logged in and got session ID and csrf token. Now the attacker logged into same website with his credentials now he got his session ID and csrf token now if he replaces the user A csrf token with his token and session ID of user’s A. As the server checks the csrf token and session separately makes this like he is valid user but the attacker uses the csrf token and session of different users.&lt;/li&gt;
  &lt;li&gt;This one usually happen when we use different framework or library for session ID and csrf token.&lt;/li&gt;
  &lt;li&gt;However, setting a cookie with the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HttpOnly&lt;/code&gt; flag means JavaScript cannot access it. This helps mitigate the risk of token theft via XSS. But it will happens when the sites under same domain&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;csrf-token-is-simply-duplicated-in-a-cookie&quot;&gt;CSRF token is simply duplicated in a cookie&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;So in this the token is generated in the server and send to the user as cookie and also in the form in hidden. So when we requested the server just check the cookie and form csrf token is same or not.&lt;/li&gt;
  &lt;li&gt;If not reject the request. Here is the catch if the attacker get his csrf token and placed in the cookie and form. The changing of cookie value only happens when cookie has property &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sameOrigin&lt;/code&gt; as none or the website is in subdomain. Which makes easy to set the cookie value.&lt;/li&gt;
  &lt;li&gt;Happening of the attack very rare but have vulnerability allow access based on the property application subdomain.&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 27 Jun 2025 07:11:00 +0000</pubDate>
        <link>http://sajjapremsai.github.io/blogs/2025/06/27/csrf-attacks/</link>
        <guid isPermaLink="true">http://sajjapremsai.github.io/blogs/2025/06/27/csrf-attacks/</guid>
        
        
      </item>
    
  </channel>
</rss>
